/*
var parser = require('parser.js');
var jsonfile = require('jsonfile')
var file = '/var/KNX/KNX.json'
jsonfile.spaces = 4
*/

var fs = require("fs");
var app = require("../app.js");

var KnxFile = '/var/KNX/KNX.json';
fs.open(KnxFile, 'a+', function(err, fd)
{
	if (err)
	{
		return console.error(err);
	}
	console.log(KnxFile + " open for append");
});


// Receive and decode the KNX packet

var KnxLength;

var KnxCtrlPrio;
var KnxCtrlRep;

var KnxSendArea;
var KnxSendLine;
var KnxSendDev;

var KnxDestArea;
var KnxDestLine;
var KnxDestHex;
var KnxDestDev;
var KnxDestGroup;
var KnxDest;
var KnxDestMainGroup;
var KnxDestMiddleGroup;

var KnxRouting;
var KnxCount;
var KnxT_Pdu_CT;
var KnxT_Pdu_SeqNr;
var KnxA_Pdu_CD;
var KnxA_Pdu_APCI;


var KnxData="00000000000000000000";
var KnxDataStr="00000000000000000000";

var KnxCheck;

exports.KnxPacketDecode = function(data)
{
	KnxLength = data[0];
		// Debug
		console.log("--------------------------------------------------------------------------------------------------");
		console.log("---> RX telegram of: " + KnxLength + " bytes at " + ISODateString());
		// Debug
		
	if((KnxLength>0) && (KnxLength<=23) && (KnxLength===(data.length-1)))
	{
		var Packet="";
		
		for (var i=1; i <= KnxLength; i++)
		{
			Packet=Packet + " " + decToHex(data[i]);
		}
		
		// Debug
		console.log(Packet);
		// Debug

		if(KnxLength>=9)
		{
			var KnxCtrlPrioNum = decToBit(data[1],2) + decToBit(data[1],3)*2; // Priority: control byte bit 3-2 
			switch(KnxCtrlPrioNum)
			{
				case 0b00:
					KnxCtrlPrio = "System";
					break;
				case 0b10:
					KnxCtrlPrio = "Alarm";
					break;
				case 0b01:
					KnxCtrlPrio = "High Prio";
					break;
				case 0b11:
					KnxCtrlPrio = "Low Prio";
					break;
			}
			
			var KnxCtrlRepNum = decToBit(data[1],5); // 0=repeated
			if(KnxCtrlRepNum===0)
			{
				KnxCtrlRep="Yes";
			}
			else
			{
				KnxCtrlRep="No";
			}
			
			KnxSendArea = decToBit(data[2],4) + decToBit(data[2],5)*2 + decToBit(data[2],6)*4 + decToBit(data[2],7)*8; // Sender Area
			KnxSendLine = decToBit(data[2],0) + decToBit(data[2],1)*2 + decToBit(data[2],2)*4 + decToBit(data[2],3)*8; // Sender Line
			KnxSendDev = data[3];	// Sender Device
			KnxSendHex = decToHex(data[2])+" "+decToHex(data[3]);	// Sender as HEX bytes
			
			var KnxDestGroupNum = decToBit(data[6],7); // Address: 0=device 1=group
			if(KnxDestGroupNum===0)
			{
				KnxDestGroup = "Individual"
			}
			else
			{
				KnxDestGroup = "Group"
			}
			
			if(KnxDestGroupNum===0) // physical address
			{
				KnxDestArea = decToBit(data[4],4) + decToBit(data[4],5)*2 + decToBit(data[4],6)*4 + decToBit(data[4],7)*8; // Destination Area
				KnxDestLine = decToBit(data[4],0) + decToBit(data[4],1)*2 + decToBit(data[4],2)*4 + decToBit(data[4],3)*8; // Destination Line
				KnxDestMainGroup="NA";
				KnxDestMiddleGroup="NA";
			}
			else
			{
				KnxDestMainGroup = decToBit(data[4],3) + decToBit(data[4],4)*2 + decToBit(data[4],5)*4 + decToBit(data[4],6)*8; // Main Group
				KnxDestMiddleGroup = decToBit(data[4],0) + decToBit(data[4],1)*2 + decToBit(data[4],2)*4; // Middle Group
				KnxDestArea="NA";
				KnxDestLine="NA";
			}
			KnxDest = data[4];
			KnxDestDev = data[5];	// Destination device or Subgroup
			KnxDestHex = decToHex(data[4])+" "+decToHex(data[5]);	// Destination as HEX bytes
			
			KnxRouting = decToBit(data[6],4) + decToBit(data[6],5)*2 + decToBit(data[6],6)*4;
			KnxCount = decToBit(data[6],0) + decToBit(data[6],1)*2 + decToBit(data[6],2)*4 + decToBit(data[6],3)*8; // data counter 0-15
			
			var KnxT_Pdu_CTnum=decToBit(data[7],6) + decToBit(data[7],7)*2;	//type of Transport Layer communication
			switch(KnxT_Pdu_CTnum)
			{
				case 0b00:
					KnxT_Pdu_CT = "Unnumbered Data Packet (UDP)";
					break;
				case 0b01:
					KnxT_Pdu_CT = "Numbered Data Packet (NDP)";
					break;
				case 0b10:
					KnxT_Pdu_CT = "Unnumbered Control Data (UCD)";
					break;
				case 0b11:
					KnxT_Pdu_CT = "Numbered Control Data (NCD)";
					break;
			}
			
			
			if(KnxT_Pdu_CTnum===0b01 | KnxT_Pdu_CTnum===0b11) //only in case of numbered comm
			{
				KnxT_Pdu_SeqNr=decToBit(data[7],2) + decToBit(data[7],3)*2 + decToBit(data[7],4)*4 + decToBit(data[7],5)*8; // Sequence number
			}
			else
			{
				KnxT_Pdu_SeqNr="NA";
			}
			
			
			if(KnxT_Pdu_CTnum===0b10 | KnxT_Pdu_CTnum===0b11) //in case of Control Data
			{
				KnxT_Pdu_CDnum=decToBit(data[7],0) + decToBit(data[7],1)*2; // Control Data
				
				switch(KnxT_Pdu_CDnum)
				{
					case 0b00:
						KnxT_Pdu_CD = "UCD:	Connect";
						break;
					case 0b01:
						KnxT_Pdu_CD = "UCD:	Disconnect";
						break;
					case 0b10:
						KnxT_Pdu_CD = "NCD:	Pos.Confirm";
						break;
					case 0b11:
						KnxT_Pdu_CD = "NCD:	Neg.confirm";
						break;
				}
				
			}
			else
			{
				KnxT_Pdu_CD="NA";
			}
			
			
			if(KnxT_Pdu_CTnum===0b00 | KnxT_Pdu_CTnum===0b01) //in case of Data Packet
			{
				KnxT_Pdu_APCInum=decToBit(data[8],6) + decToBit(data[8],7)*2 + decToBit(data[7],0)*4 + decToBit(data[7],1)*8; // application layer services
				
				switch(KnxT_Pdu_APCInum)
				{
					case 0b0000:
						KnxT_Pdu_APCI = "GroupValueRead";
						break;
					case 0b0001:
						KnxT_Pdu_APCI = "GroupValueResponse";
						break;
					case 0b0010:
						KnxT_Pdu_APCI = "GroupValueWrite";
						break;
					case 0b0011:
						KnxT_Pdu_APCI = "IndividualAddrWrite";
						break;
					case 0b0100:
						KnxT_Pdu_APCI = "IndividualAddrRequest";
						break;
					case 0b0101:
						KnxT_Pdu_APCI = "IndividualAddrResponse";
						break;
					case 0b0110:
						KnxT_Pdu_APCI = "AdcRead";
						break;
					case 0b0111:
						KnxT_Pdu_APCI = "AdcResponse";
						break;
					
					case 0b1000:
						KnxT_Pdu_APCI = "MemoryRead";
						break;
					case 0b1001:
						KnxT_Pdu_APCI = "MemoryResponse";
						break;
					case 0b1010:
						KnxT_Pdu_APCI = "MemoryWrite";
						break;
					case 0b1011:
						KnxT_Pdu_APCI = "UserMessage";
						break;
					case 0b1100:
						KnxT_Pdu_APCI = "MaskVersionRead";
						break;
					case 0b1101:
						KnxT_Pdu_APCI = "MaskVersionResponse";
						break;
					case 0b1110:
						KnxT_Pdu_APCI = "Restart";
						break;
					case 0b1111:
						KnxT_Pdu_APCI = "Escape";
						break;
				}
				
			}
			else
			{
				KnxT_Pdu_APCI="NA";
			}
			
			
			KnxDataStr="";
			KnxData=0;
			var Payload="";
		
			for(var i=0; i<KnxCount; i++)
			{
				KnxData[i]=data[8+i];
				Payload=Payload + " " + decToHex(data[8+i]);
			}
		
			KnxCheck = data[8+KnxCount];	//last byte is the checksum

			/* Debug
			console.log(Packet);
			console.log("Priority:" + KnxCtrlPrio+ " - Repetion:" + KnxCtrlRep );
			console.log("Send Area:" + KnxSendArea + " - Send Line:" + KnxSendLine + " - Send Dev:" + KnxSendDev);
			console.log("Dest Area:" + KnxDestArea + " - Dest Line:" + KnxDestLine + " - Dest Dev:" + KnxDestDev + " - Dest Group:" + KnxDestGroup);
			console.log("Routing:" + KnxRouting + " - Counter:" + KnxCount + " - PDU:" + KnxPdu);
			console.log("Data:" + Payload+" hex");
			console.log("Checksum:" + KnxCheck);
			Debug*/
			
			var d = new Date();
			KNXdecoded = 
			{
				'Date'			: ISODateString(),
				'Length' 		: KnxLength,
				'Prio'			: KnxCtrlPrio,
				'Rep'			: KnxCtrlRep,
				'SendArea'		: KnxSendArea,
				'SendLine'		: KnxSendLine,
				'SendDev'		: KnxSendDev,
				'DestGroup'		: KnxDestGroup,
				'DestArea'		: KnxDestArea,
				'DestLine'		: KnxDestLine,
				'Dest'			: KnxDest,
				'DestMainGroup'	: KnxDestMainGroup,
				'DestMidGroup'	: KnxDestMiddleGroup,
				'DestDev'		: KnxDestDev,
				'SendHex'		: KnxSendHex,
				'DestHex'		: KnxDestHex,
				'Routing'		: KnxRouting,
				'Count'			: KnxCount,
				'T_Pdu_CT'		: KnxT_Pdu_CT,
				'T_PDU_SeqNr'	: KnxT_Pdu_SeqNr,	
				'Pdu_CD'		: KnxT_Pdu_CD,
				'Pdu_APCI'		: KnxT_Pdu_APCI,
				'Payload'		: Payload,
				'Check'			: KnxCheck,
				'Telegram'		: Packet,
				'Dawn'			: hsorge,
				'Dusk'			: htram,
				'Lat'			: Latit,
				'Lon'			: Longi,
				'Hour'			: d.getHours(),
				'Minute'		: d.getMinutes()
			}
		}
		else
		{
			KNXdecoded = 
			{
			'Telegram'		: Packet
			}
		}
		
		if(CLIENT!=0)
		{
			CLIENT.emit('RxEvent', JSON.stringify(KNXdecoded));
		}

		fs.appendFile(KnxFile, JSON.stringify(KNXdecoded,null, 4)+'\r', function(err) 
		{
			if (err) 
			{
				return console.error(err);
			}	
		});		
	}
}

function decToHex(Dec)
{//return HEX value 0 padded
	var dataHex = ("00" + (Dec.toString(16))).slice(-2);
	return dataHex.toUpperCase();
}

function decToBit(Dec, Pos)
{//return bit value in a precise position
	var dataBin = ("00000000" + (Dec.toString(2))).slice(-8); //zero pad
	Pos=Math.abs(Pos-7); // reverse order
	return parseInt(dataBin[Pos]);
}

exports.KnxInit = function()
{
	KnxPort.write("@MX");		//KNXgate HEX mode
  	var end = Date.now() + 500
	while (Date.now() < end) ;
	KnxPort.write("@Ae40C");	//exclude group 0C from logging (unknown device)
	var end = Date.now() + 500
	while (Date.now() < end) ;
	KnxPort.write("@b");		//flush KNXgate buffer
	//ResetComm();				//flush RX buffer
	var end = Date.now() + 500
	while (Date.now() < end) ;
	KnxPort.write("@l");		//start receiving data in interrupt mode. Comment line for polling mode
}


/*-----------------------------------------------------------------------------*/
WFAflag = 0;
WFAcount = 0;
WFAtime = 0;
waitForAnswer = function()
{// initialize the counting for no answer at all from peripherals
  WFAflag = 1;  // is waiting
  WFAtime = Date.now(); // start timeout counting
};

answerReceived = function()
{// reset count when full packet received correctly
  WFAflag = 0;  // no more waiting
  WFAcount = 0; // reset timeouts count
  RxStatus = 0;
  Parser();      // decode ready message packet 
};


/*-----------------------------------------------------------------------------*/
MAX_BUFF = 25; // buffer size
var TxBuff = new Buffer(MAX_BUFF); // TX buffer 

exports.txTelegram = function(Line, Dev, Cmd, Count)
{

    var TxChkSum = 0;
    var indx=2; 
 
    TxBuff.writeUInt8(0XB4,++indx) ;
    TxBuff.writeUInt8(0X11,++indx);       
    TxBuff.writeUInt8(0XF0,++indx) ;
    TxBuff.writeUInt8(Line,++indx);   
    TxBuff.writeUInt8(Dev,++indx) ;
    TxBuff.writeUInt8(0XE0+Count,++indx);       
    TxBuff.writeUInt8(0X00,++indx);
    TxBuff.writeUInt8(Cmd+0X80,++indx); 
    if(Count===2)
    {
    	TxBuff.writeUInt8(Dev,++indx); 
    } 
  
  	TxBuff.write("@",0) ;
    TxBuff.write("W",1);
    TxBuff.writeUInt8(indx-1,2);
    
  	var TxChkSum = 0;
    for (var i=3; i <= indx; i++)
    {// compute the checksum
      TxChkSum = (TxChkSum ^ TxBuff[i]) & 0xFF;
    }
	TxChkSum = ((TxChkSum ^ 0xFF)) & 0xFF;   
	 
    TxBuff.writeUInt8(TxChkSum,++indx);
    
	// Debug
	var Packet="";
    for (var i=3; i <= indx; i++)
	{
		Packet=Packet + " " + decToHex(TxBuff[i]);
	}
	
	console.log("--------------------------------------------------------------------------------------------------");
	console.log("<--- TX telegram of: " + (indx-2) + " bytes at " + ISODateString());
	console.log(Packet);
	// Debug
	

    KnxPort.write(TxBuff.slice(0, indx+1));
    
};

/*-----------------------------------------------------------------------------*/
startTime = 0; 
var elapsed;        // to manage timeout
RxCmd=0;

/*-----------------------------------------------------------------------------*/
ResetComm = function ()
{// reset the communication ports and status
  RxStatus=0; 
  WFAflag = 0;  // no more waiting for answer
  WFAcount = 0; // reset timeouts count
  RxChkSum=0;
  KnxPort.flush();
};

var RxTime = Date.now(); //debug

